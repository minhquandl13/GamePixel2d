1
00:00:00,504 --> 00:00:02,000
Привет, ребята, это RyiSnow 

2
00:00:02,345 --> 00:00:08,571
Итак, в прошлый раз мы загрузили нашу карту мира и реализовали функцию камеры  

4
00:00:08,571 --> 00:00:12,201
так что теперь мы можем перемещаться по миру

5
00:00:12,201 --> 00:00:17,775
но все же, мы можем пройти через эти деревья и воды

6
00:00:17,775 --> 00:00:23,156
поэтому в этом видео мы реализуем обнаружение столкновений в нашей программе

7
00:00:23,156 --> 00:00:29,492
чтобы игрок не смог пройти через сплошные плитки.

8
00:00:29,492 --> 00:00:35,874
Когда мы создали класс Tile, мы создали булево значение "collision". 

9
00:00:35,874 --> 00:00:38,431
так что пришло время использовать это

10
00:00:38,431 --> 00:00:42,000
сначала мы переходим к этому TileManager

11
00:00:42,000 --> 00:00:48,469
и ищем плитку, которую мы хотим изменить на сплошную.

12
00:00:48,469 --> 00:00:53,081
например, эта настенная плитка должна быть сплошной

13
00:00:53,081 --> 00:00:57,931
мы не хотим, чтобы наш персонаж игрока проходил через эту плитку

14
00:01:01,936 --> 00:01:08,286
мы называем это столкновение булевым и устанавливаем его в "true".

15
00:01:12,000 --> 00:01:16,426
также этот водный тайл... и этот тоже

16
00:01:22,654 --> 00:01:26,521
и эта тоже

17
00:01:31,837 --> 00:01:36,755
и если это не сплошная плитка... как эта плитка с травой

18
00:01:36,755 --> 00:01:44,829
тогда вам не нужно ничего добавлять, потому что коллизия по умолчанию ложная.

19
00:01:44,829 --> 00:01:50,384
поэтому вам нужно добавить это, только если плитка цельная

20
00:01:51,366 --> 00:01:54,197
Итак, настройка столкновений плиток выполнена

21
00:01:54,568 --> 00:02:02,563
затем мы решаем, какая часть персонажа игрока является твердой, а какая нет

22
00:02:03,836 --> 00:02:07,905
Самый простой способ - установить всю плитку сплошной

23
00:02:07,905 --> 00:02:12,478
но иногда это не дает наилучшего результата

24
00:02:12,478 --> 00:02:17,051
например, если весь спрайт игрока замазан,

25
00:02:17,051 --> 00:02:24,940
то он ударяется об эту стену в этой точке и не может двигаться дальше

26
00:02:24,940 --> 00:02:30,760
но, возможно, вы хотите переместить его немного дальше... вот так

27
00:02:33,811 --> 00:02:36,342
также, есть еще один вопрос

28
00:02:36,342 --> 00:02:44,921
если все твердое, то очень трудно пройти по узкому пути, как этот

29
00:02:44,921 --> 00:02:54,243
потому что даже если игрок находится на 1 пиксель левее, столкновение все равно происходит здесь

30
00:02:55,039 --> 00:03:00,143
поэтому вам нужно расположить его очень точно, вот так

31
00:03:01,257 --> 00:03:08,944
и это просто довольно напряженно и плохая механика управления, на мой взгляд.

33
00:03:09,501 --> 00:03:15,533
например, "о, я бьюсь об эту плитку, так что давайте немного сдвинемся вправо".

34
00:03:15,533 --> 00:03:21,035
и "о, теперь я бьюсь об эту плитку и все еще не могу пройти дальше".

35
00:03:21,035 --> 00:03:24,918
чтобы избежать подобных неприятностей,

36
00:03:24,918 --> 00:03:31,189
мы задаем определенную область персонажа как твердую, а не всю.

37
00:03:31,189 --> 00:03:36,000
например, только эта часть твердая

38
00:03:36,000 --> 00:03:40,918
тогда игрок сможет пройти через этот узкий путь

39
00:03:40,918 --> 00:03:44,616
и установить вот такую область столкновения,

40
00:03:44,616 --> 00:03:48,844
сначала откройте эту сущность

41
00:03:53,363 --> 00:03:59,395
мы используем этот класс Rectangle

42
00:03:59,395 --> 00:04:05,639
и я назову его solidArea

43
00:04:08,769 --> 00:04:15,199
С помощью этого класса мы можем создать невидимый или абстрактный прямоугольник

44
00:04:15,199 --> 00:04:19,772
и мы можем хранить такие данные, как x, y, ширина и высота.

45
00:04:20,594 --> 00:04:31,295
Также мы создаем булево значение под названием collisionOn, и по умолчанию оно равно false

46
00:04:32,913 --> 00:04:36,292
Теперь перейдем к классу Player

47
00:04:36,292 --> 00:04:40,600
и инстанцируем этот прямоугольник

48
00:04:55,906 --> 00:05:08,703
подождите, что это...

49
00:05:11,170 --> 00:05:18,000
и когда мы создаем этот прямоугольник, мы можем передать конструктору 4 параметра

50
00:05:23,093 --> 00:05:30,823
например, если вы хотите создать прямоугольник, который будет такого же размера, как наша плитка,

51
00:05:30,823 --> 00:05:32,823
вы напечатаете вот так:

52
00:05:32,823 --> 00:05:39,969
x=0, y=0, widht=48 и height=48

53
00:05:39,969 --> 00:05:46,054
или вы можете набрать так: gp.tileSize

54
00:05:46,187 --> 00:05:48,797
любой способ подходит

55
00:05:48,797 --> 00:05:57,906
или мы также можем оставить это пустое место и установить эти значения по одному

56
00:06:23,158 --> 00:06:25,158
любой способ подходит

57
00:06:25,158 --> 00:06:31,734
и поскольку мы хотим сделать этот прямоугольник немного меньше, чем персонаж игрока

58
00:06:31,734 --> 00:06:35,803
мы немного изменим эти значения

59
00:06:36,287 --> 00:06:38,287
может быть что-то вроде этого

60
00:06:38,307 --> 00:06:43,968
так что эта серая область не является сплошной, а эта область сплошная

61
00:06:43,968 --> 00:06:50,716
так что эта скользящая область начинается с x 8

62
00:06:50,716 --> 00:06:58,828
ширина 32 и высота тоже 32

64
00:06:58,828 --> 00:07:05,868
так что левый верхний угол имеет x=8, а y=16

65
00:07:05,868 --> 00:07:14,871
так что в этом случае мы изменим x на 8, а y на 16

66
00:07:14,871 --> 00:07:22,256
и ширина равна 32, а высота также равна 32

67
00:07:22,548 --> 00:07:28,474
вы можете настроить эти числа и найти то, что лучше всего подходит для вашей игры

68
00:07:28,474 --> 00:07:32,570
Итак, мы получили эту область столкновения для персонажа игрока

69
00:07:32,570 --> 00:07:36,851
Теперь давайте создадим класс для проверки столкновений

70
00:07:36,851 --> 00:07:41,557
внутри этого пакета "main" создайте класс

71
00:07:41,557 --> 00:07:51,038
и я собираюсь назвать это CollisionChecker или любое другое имя, которое вы хотите

72
00:07:52,868 --> 00:07:55,717
и сначала конструктор

73
00:08:00,121 --> 00:08:03,076
и мы получаем GamePanel

74
00:08:17,586 --> 00:08:20,647
и создаем метод

75
00:08:28,154 --> 00:08:35,778
и получаем здесь Entity

76
00:08:40,340 --> 00:08:43,189
не Игрок, а Сущность

77
00:08:43,189 --> 00:08:54,155
потому что мы будем использовать этот метод для проверки столкновений не только игрока, но и монстров и NPC.

78
00:08:56,304 --> 00:08:58,516
теперь перейдем к панели GamePanel

79
00:08:59,206 --> 00:09:04,124
и инстанцируйте этот класс CollisionChecker

80
00:09:19,085 --> 00:09:21,854
и передаем эту GamePanel

81
00:09:24,268 --> 00:09:26,825
и теперь перейдите к этому классу Player

82
00:09:26,825 --> 00:09:32,061
и проверяем столкновение внутри этого метода обновления

83
00:09:35,801 --> 00:09:39,180
после этого оператора направления if,

84
00:09:40,506 --> 00:09:48,000
сначала мы устанавливаем для этого collisionOn значение false

85
00:09:50,000 --> 00:09:53,565
затем вызываем это...

86
00:10:00,170 --> 00:10:02,170
ой, простите

87
00:10:03,231 --> 00:10:06,151
это должно быть "публичным"

88
00:10:08,936 --> 00:10:15,552
поэтому мы собираемся вызвать этот метод checkTile отсюда

89
00:10:15,552 --> 00:10:19,542
и передадим этот класс Player как Entity 

90
00:10:19,542 --> 00:10:23,770
поскольку этот класс Player является подклассом этого класса Entity 

91
00:10:23,770 --> 00:10:28,502
поэтому CollisionChecker может получить класс Player как Entity

92
00:10:29,722 --> 00:10:33,632
хорошо, теперь основная часть этого видео

93
00:10:33,632 --> 00:10:42,847
Нам нужно проверить, попадает ли игрок на твердую плитку или нет.

94
00:10:43,484 --> 00:10:51,797
для этого, во-первых, мы хотим знать worldX и worldY solidArea игрока

95
00:10:51,797 --> 00:11:00,721
не worldX и Y игрока, потому что коллизия должна быть обнаружена на основе этих координат solidArea

96
00:11:01,225 --> 00:11:04,100
есть 4 точки, которые необходимо проверить

97
00:11:17,668 --> 00:11:22,480
и мы можем узнать эти 4 числа следующим образом:

98
00:12:52,672 --> 00:13:01,410
Затем, исходя из этих координат, мы узнаем их номера столбцов и строк

99
00:13:15,204 --> 00:13:20,175
просто разделим его на tileSize

100
00:14:31,401 --> 00:14:36,372
и, наконец, мы создадим еще два целых числа

101
00:14:46,505 --> 00:14:52,909
потому что, по сути, нам нужно проверить только две плитки для каждого направления

102
00:14:54,000 --> 00:14:56,318
если игрок поднимается вверх, 

103
00:14:56,500 --> 00:15:04,826
нам нужно только проверить, на какие плитки попадает левое и правое плечо игрока

104
00:15:05,591 --> 00:15:09,194
Так что в этом случае, если игрок поднимается вот так

105
00:15:09,751 --> 00:15:12,786
это ударяется... возможно, об эту настенную плитку

106
00:15:12,786 --> 00:15:16,404
а это правое плечо ударяется об эту плитку травы

107
00:15:16,404 --> 00:15:23,497
Теперь мы создадим оператор переключения

108
00:15:25,301 --> 00:15:29,795
мы проверим направление сущности

109
00:15:59,107 --> 00:16:02,990
поэтому давайте сначала разберемся с этим "вверх".

110
00:16:32,267 --> 00:16:35,779
например, игрок находится здесь и сейчас

111
00:16:35,779 --> 00:16:39,530
и он пытается подняться

112
00:16:39,530 --> 00:16:47,843
что мы делаем здесь, мы как бы предсказываем, где окажется игрок после того, как он переместился

113
00:16:59,276 --> 00:17:05,441
поэтому мы вычитаем скорость этого игрока из worldY игрока

114
00:17:05,441 --> 00:17:10,386
или, если быть точным, из worldY солид-области игрока.

115
00:17:10,970 --> 00:17:20,451
Теперь мы знаем номер ряда, чтобы узнать, на какой тайл пытается наступить игрок

116
00:17:20,451 --> 00:17:23,777
и, возможно, есть две плитки

117
00:17:35,422 --> 00:17:38,908
поэтому мы назовем это mapTileNum

118
00:17:38,908 --> 00:17:42,208
здесь хранится вся информация о плитках карты

119
00:18:03,165 --> 00:18:06,359
о, это также должно быть "публичным"

120
00:18:13,123 --> 00:18:16,017
и еще один...

121
00:18:27,132 --> 00:18:30,220
мы проверили эту точку, это tileNum1

122
00:18:30,220 --> 00:18:34,899
теперь мы хотим проверить эту точку, правую сторону

123
00:18:51,453 --> 00:18:56,265
С этой информацией мы создаем оператор if

124
00:18:56,265 --> 00:19:09,221
и вызываем этот массив Tile... он также должен быть "публичным"

125
00:19:14,712 --> 00:19:19,153
мы будем использовать этот tileNum1 в качестве индекса

126
00:19:19,153 --> 00:19:23,540
и проверим, является ли эта плитка сплошной или нет

127
00:19:44,943 --> 00:19:51,771
если одно из них или оба истинны, то игрок попадает на твердую плитку

128
00:19:51,771 --> 00:19:54,938
поэтому он не может двигаться в этом направлении
 
129
00:20:20,553 --> 00:20:26,320
если эти столкновения ложные, то мы ничего не делаем

130
00:20:27,779 --> 00:20:30,256
Итак, этот случай "вверх" завершен

131
00:20:30,256 --> 00:20:34,219
давайте вернемся к классу Player

132
00:21:36,647 --> 00:21:45,995
и теперь переместим эти линии движения игрока отсюда сюда

133
00:22:02,175 --> 00:22:06,828
возможно, этот формат мне нравится больше...

134
00:22:28,103 --> 00:22:37,557
потому что теперь мы проверяем столкновение, так что игрок может двигаться только тогда, когда плитки не твердые

135
00:22:37,557 --> 00:22:41,467
поэтому сначала мы проверяем только направление

136
00:22:41,467 --> 00:22:47,605
и, основываясь на этом направлении, мы проверяем столкновение

137
00:22:47,605 --> 00:22:53,054
и если столкновения не происходит, мы позволяем игроку двигаться.

138
00:22:55,707 --> 00:22:57,707
хорошо, давайте проверим это

139
00:23:03,623 --> 00:23:09,956
Итак, теперь эта плитка дерева останавливает персонажа игрока

140
00:23:12,000 --> 00:23:15,247
но это все еще только направление вверх

141
00:23:15,247 --> 00:23:18,998
вы все еще можете двигаться влево, вниз и вправо

142
00:23:19,370 --> 00:23:22,617
так что давайте позаботимся и о других направлениях.

143
00:23:25,111 --> 00:23:31,223
я думаю, мы можем скопировать и вставить

144
00:23:33,223 --> 00:23:38,592
мы изменим только некоторые переменные

145
00:23:39,308 --> 00:23:50,009
так что если игрок опускается вниз, мы будем проверять не topRow, а bottomRow

146
00:23:51,229 --> 00:23:57,394
поэтому измените это на bottomRow

147
00:24:18,000 --> 00:24:24,000
мы собираемся изменить это сверху вниз

148
00:24:28,615 --> 00:24:31,730
и если игрок идет налево, то...

149
00:24:31,730 --> 00:24:38,346
мы проверим LeftCol

150
00:24:39,381 --> 00:24:43,079
и leftCol будет...

151
00:24:53,637 --> 00:24:57,759
Теперь мы проверим эту точку и эту точку.

152
00:25:12,747 --> 00:25:15,516
если все идет правильно, то...

153
00:25:40,452 --> 00:25:42,452
вот и все, я думаю

154
00:25:45,980 --> 00:25:48,336
Хорошо, давайте проверим это

155
00:25:53,244 --> 00:25:55,774
хорошо, попадание в плитку

156
00:26:02,512 --> 00:26:04,512
и эта плитка с водой тоже

157
00:26:05,308 --> 00:26:07,922
так что столкновение происходит

158
00:26:09,829 --> 00:26:12,956
Ага, выглядит хорошо

159
00:26:15,105 --> 00:26:18,750
Так что это все больше и больше похоже на игру.

160
00:26:18,750 --> 00:26:21,917
поэтому мы позаботились об обнаружении столкновений

161
00:26:21,917 --> 00:26:27,206
в следующий раз мы будем создавать объекты и отображать их на экране

162
00:26:27,206 --> 00:26:30,612
чтобы игрок мог взять их в руки

163
00:26:30,851 --> 00:26:33,090
спасибо за просмотр, и до следующего раза

