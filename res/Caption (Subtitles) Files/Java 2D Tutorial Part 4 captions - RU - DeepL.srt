1
00:00:00,560 --> 00:00:07,839
в последний раз мы загрузили спрайты персонажей

3
00:00:05,279 --> 00:00:16,240
и реализовали простую систему анимации, чтобы мы могли управлять нашим персонажем-игроком

6
00:00:12,559 --> 00:00:18,720
теперь давайте нарисуем несколько фоновых плиток 

7
00:00:16,240 --> 00:00:27,599
Кстати, нам больше не нужны эти переменные, так как мы позаботились о движении игрока в классе Player

10
00:00:25,039 --> 00:00:27,599
так что вы можете удалить это

11
00:00:27,760 --> 00:00:37,760
Итак, сначала нам нужно несколько изображений фоновых плиток

13
00:00:33,840 --> 00:00:41,280
поэтому я подготовил три плитки

14
00:00:37,760 --> 00:00:45,840
позже мы добавим больше плиток, но пока трех плиток должно быть достаточно

16
00:00:43,040 --> 00:00:50,559
Итак, внутри этого ресурсного пакета создадим еще один пакет

18
00:00:48,079 --> 00:00:53,039
Я назову его "tiles"

20
00:00:54,399 --> 00:01:04,399
и мы скопируем эти изображения плиток в пакет tiles

24
00:01:07,360 --> 00:01:15,920
и затем из этой исходной папки мы создадим другой пакет

27
00:01:17,680 --> 00:01:27,560
и внутри этого пакета создадим класс под названием Tile

31
00:01:28,560 --> 00:01:37,600
и это класс, который представляет одну плитку

33
00:01:34,079 --> 00:01:38,840
и пока что мы добавляем два элемента 

34
00:01:37,600 --> 00:01:42,159
один из них...

38
00:01:47,119 --> 00:01:51,680
а другой...

43
00:02:01,759 --> 00:02:07,439
Так что этот класс пока в порядке

44
00:02:04,320 --> 00:02:10,959
теперь давайте создадим другой класс

45
00:02:07,439 --> 00:02:13,120
внутри этого плиточного пакета

46
00:02:10,959 --> 00:02:17,280
Я назову этот пакет TileManager

49
00:02:17,360 --> 00:02:24,239
в этом классе сначала мы будем использовать GamePanel

52
00:02:24,239 --> 00:02:30,000
а также этот класс Tile

55
00:02:30,000 --> 00:02:37,840
мы создаем эту плитку как переулок и называем ее "плитка"

57
00:02:38,319 --> 00:02:44,319
import GamePanel

58
00:02:40,480 --> 00:02:46,879
тогда давайте создадим конструктор

60
00:02:46,879 --> 00:02:53,200
и получим GamePanel как "gp".

64
00:02:58,800 --> 00:03:06,080
также мы установим размер этого массива Tile

67
00:03:06,080 --> 00:03:11,360
я выберу 10 пока что 

68
00:03:10,319 --> 00:03:16,319
это означает, что мы создадим 10 видов плиток

70
00:03:13,120 --> 00:03:22,000
например, стеклянная плитка, плитка для воды, плитка для стен...

72
00:03:19,440 --> 00:03:31,120
Если нам нужно больше, мы всегда можем изменить это число на 15 или 20.

75
00:03:27,599 --> 00:03:35,200
но я думаю, что 10 достаточно

76
00:03:31,120 --> 00:03:39,120
затем создайте метод

78
00:03:41,040 --> 00:03:48,480
и мы вызовем этот метод из этого конструктора

81
00:03:48,720 --> 00:03:54,560
аналогично классу Player

82
00:03:51,920 --> 00:04:01,840
поэтому мы собираемся загрузить эти изображения плиток в этом методе getTileImage 

84
00:03:58,319 --> 00:04:01,840
так что снова пробуем и ловим

88
00:04:14,560 --> 00:04:22,400
и здесь мы создадим массив Tile.

101
00:04:46,880 --> 00:04:53,280
и затем введем путь к файлу

103
00:04:50,080 --> 00:04:58,000
Так что путь к файлу будет... поскольку они находятся внутри этого пакета плиток, так что...

108
00:05:03,520 --> 00:05:12,240
Итак, мы создали это BufferedImage внутри этого класса Tile

111
00:05:10,720 --> 00:05:20,240
мы собираемся поместить изображение файла плитки в этот BufferedImage

114
00:05:17,520 --> 00:05:24,639
давайте скопируем это и вставим

119
00:05:28,560 --> 00:05:36,840
и плитка[1] будет стеной

121
00:05:33,360 --> 00:05:42,160
а плитка[2] будет водой

123
00:05:39,759 --> 00:05:44,479
инстанцирование выполнено

124
00:05:42,160 --> 00:05:54,560
и мы создаем метод рисования внутри этого TileManager.

132
00:06:00,479 --> 00:06:06,639
import

133
00:06:02,720 --> 00:06:09,919
Итак, давайте нарисуем плитку для тестирования

134
00:06:06,639 --> 00:06:11,440
Чтобы нарисовать плитку, введите вот так 

139
00:06:17,520 --> 00:06:24,639
Итак, сначала BufferedImage

141
00:06:20,400 --> 00:06:25,759
так что давайте нарисуем эту плитку травы

144
00:06:27,280 --> 00:06:34,560
и затем x и y, так что 0 и 0

146
00:06:32,160 --> 00:06:44,000
и ширина и высота, так что gp.tileSize и gp.tileSize

149
00:06:38,639 --> 00:06:46,479
а ImageObserver равен null

151
00:06:46,720 --> 00:06:52,639
а теперь перейдем к классу GamePanel

153
00:06:52,639 --> 00:07:00,840
инстанцируем этот TileManager

160
00:07:06,319 --> 00:07:14,160
и передаем этот класс GamePanel

163
00:07:14,160 --> 00:07:22,880
затем внутри этого paintComponent мы введем...

167
00:07:22,880 --> 00:07:30,400
и вызовем метод draw внутри TileManager.

170
00:07:28,639 --> 00:07:38,560
и убедитесь, что ввели эту строку перед этим "player.draw(g2)"

173
00:07:35,440 --> 00:07:43,919
так что это как слой. в данном случае мы сначала рисуем тайлы, затем игрока.

175
00:07:41,680 --> 00:07:55,360
если все наоборот, то фоновые плитки скроют персонажа игрока, так что мы не сможем увидеть персонажа игрока

179
00:07:51,120 --> 00:07:58,840
поэтому убедитесь, что плитки нарисованы перед игроком

180
00:07:55,360 --> 00:07:58,840
давайте проверим это

181
00:07:58,960 --> 00:08:04,800
да, хорошо

182
00:08:00,879 --> 00:08:06,879
Итак, наша первая плитка отображается

183
00:08:04,800 --> 00:08:09,599
Так что давайте нарисуем еще несколько плиток

184
00:08:06,879 --> 00:08:13,120
поэтому вернемся к этому классу TileManager

185
00:08:09,599 --> 00:08:16,479
давайте скопируем это и вставим

187
00:08:15,039 --> 00:08:24,960
нарисуем плитку стены и плитку воды

190
00:08:20,960 --> 00:08:29,840
но мы должны изменить эти x и y, иначе они просто перезапишутся.

192
00:08:28,160 --> 00:08:34,560
поэтому давайте добавим размер плитки к x

195
00:08:34,560 --> 00:08:46,480
и снова добавим размер плитки, так что 48 плюс 48 будет 96

198
00:08:44,080 --> 00:08:49,279
хорошо, давайте проверим это

199
00:08:46,480 --> 00:08:56,560
Итак, мы нарисовали плитку травы, плитку стены и плитку воды.

204
00:08:56,560 --> 00:09:01,640
вот так мы можем рисовать плитки на экране

207
00:09:14,560 --> 00:09:17,680
так что давайте проверим это

208
00:09:18,800 --> 00:09:21,360
хорошо

210
00:09:23,519 --> 00:09:33,200
я только что создал 5 плиток по горизонтали, 5 плиток по вертикали

213
00:09:30,720 --> 00:09:34,399
вот что я напечатал

214
00:09:33,200 --> 00:09:44,320
но очевидно, что это не самый эффективный способ печатать или рисовать

218
00:09:41,279 --> 00:09:46,160
просто слишком много печатать

219
00:09:44,320 --> 00:09:53,279
поэтому нам нужна более эффективная система рисования плитки

221
00:09:50,560 --> 00:09:57,120
так что давайте не будем этого делать

222
00:09:53,279 --> 00:10:00,399
Вместо этого мы создадим цикл while

223
00:09:57,120 --> 00:10:06,399
и как бы автоматизируем процесс, чтобы избежать большого количества набора текста

225
00:10:02,959 --> 00:10:08,720
сначала создадим несколько переменных

235
00:10:25,839 --> 00:10:30,800
затем создайте цикл while

237
00:10:30,880 --> 00:10:41,920
этот цикл продолжается, если col меньше, чем gp.max...

241
00:10:39,839 --> 00:10:43,120
о, хорошо

242
00:10:41,920 --> 00:10:46,640
ах, простите

243
00:10:43,120 --> 00:10:50,480
нам нужно изменить эти переменные на "public"

253
00:11:02,959 --> 00:11:08,680
а также этот целочисленный ряд меньше, чем...

258
00:11:14,399 --> 00:11:20,959
поэтому внутри этого цикла мы будем рисовать плитки.

262
00:11:23,040 --> 00:11:29,839
поэтому сейчас давайте нарисуем плитку травы

268
00:11:36,399 --> 00:11:41,120
это переменные

271
00:11:46,560 --> 00:11:48,959
хорошо

272
00:11:48,079 --> 00:11:53,600
во-первых, col - 0 и row - 0 

274
00:11:51,519 --> 00:11:56,639
x - 0 и y - 0

275
00:11:53,600 --> 00:12:00,399
в основном это 0:0

276
00:11:56,639 --> 00:12:02,720
поэтому он нарисует плитку в 0:0

277
00:12:00,399 --> 00:12:02,720
здесь

278
00:12:02,959 --> 00:12:09,920
после этого мы увеличим это значение на 1

280
00:12:08,240 --> 00:12:12,560
и затем мы увеличим это x

288
00:12:30,240 --> 00:12:36,720
так что мы увеличиваем этот col на единицу 

289
00:12:33,360 --> 00:12:43,120
и если это достигнет MaxScreenCol, который равен 16

291
00:12:39,360 --> 00:12:49,120
тогда мы сбросим этот col и также сбросим этот x

293
00:12:46,720 --> 00:12:54,639
и затем увеличим этот ряд на 1

295
00:12:50,720 --> 00:12:56,160
и также увеличиваем этот ряд по y

299
00:13:02,880 --> 00:13:08,880
Хорошо, я думаю. Давайте проверим это

301
00:13:11,200 --> 00:13:20,160
Итак, нам удалось разместить плитки на весь экран

304
00:13:16,800 --> 00:13:22,320
но мы используем только плитку травы

305
00:13:20,160 --> 00:13:27,519
поэтому для рендеринга реальной карты мы сначала создаем данные карты

307
00:13:26,560 --> 00:13:34,399
затем позволим этому циклу считать данные

309
00:13:30,480 --> 00:13:38,480
и для хранения данных карты мы используем текстовый файл

311
00:13:35,600 --> 00:13:44,560
это простой, но довольно популярный и эффективный метод.

313
00:13:41,839 --> 00:13:50,000
поэтому сначала откройте этот блокнот

315
00:13:47,199 --> 00:13:51,279
и затем мы напечатаем...

320
00:14:00,399 --> 00:14:10,399
скопируем это и вставим 11 раз.

323
00:14:10,399 --> 00:14:18,720
так что в одной строке 16 нулей и в ней 12 строк

325
00:14:16,800 --> 00:14:24,320
и каждое число представляет собой плитку

327
00:14:20,880 --> 00:14:33,040
так что это карта плиток 16x12, что соответствует размеру нашего экрана

329
00:14:28,000 --> 00:14:38,320
и этот 0 означает номер тайла, так что это тайл травы.

331
00:14:35,920 --> 00:14:42,800
так что если вы хотите поместить плитку стены, вам просто нужно изменить это на 1

334
00:14:42,839 --> 00:14:52,160
а если мы хотим поместить плитку воды, измените число на 2

338
00:14:52,160 --> 00:14:57,639
Позвольте мне быстро создать пример карты

340
00:15:08,480 --> 00:15:13,839
что-то вроде этого

341
00:15:10,000 --> 00:15:13,839
теперь давайте сохраним файл

342
00:15:14,320 --> 00:15:23,040
я назову его просто "map01.txt".

346
00:15:24,839 --> 00:15:31,440
затем внутри этой папки res создадим еще один пакет

349
00:15:32,560 --> 00:15:37,920
Я назову его "maps".

351
00:15:38,800 --> 00:15:46,240
где файл?

354
00:15:46,240 --> 00:15:54,600
Итак, мы скопируем этот файл карты в папку "maps".

358
00:15:54,880 --> 00:16:03,839
Итак, у нас есть файл данных карты, так что давайте загрузим эти данные.

360
00:16:01,440 --> 00:16:06,839
сначала создайте переменную

367
00:16:13,920 --> 00:16:20,959
и это будет массив

369
00:16:18,480 --> 00:16:27,839
и внутри этого конструктора мы собираемся инстанцировать mapTileNum

373
00:16:29,839 --> 00:16:33,600
и размер...

379
00:16:42,160 --> 00:16:54,959
Так что, по сути, мы собираемся поместить все эти числа в массив mapTileNum

383
00:16:52,800 --> 00:16:59,519
поэтому для этого мы создадим еще один метод

388
00:17:04,559 --> 00:17:08,240
так что еще одна попытка и catch

389
00:17:10,400 --> 00:17:15,120
на этот раз просто "Exception e"

392
00:17:20,720 --> 00:17:26,480
мы будем использовать этот класс InputStream

397
00:17:31,120 --> 00:17:41,520
и здесь мы введем путь к файлу этого текстового файла

406
00:17:49,840 --> 00:17:55,360
и импортируем этот InputStream

421
00:18:16,160 --> 00:18:21,280
импортировать это

423
00:18:19,440 --> 00:18:23,520
а также это

426
00:18:23,520 --> 00:18:33,840
Итак, мы использовали этот InputStream для импорта этого текстового файла

428
00:18:30,960 --> 00:18:42,400
и мы собираемся использовать этот BufferedReader для чтения содержимого этого текстового файла

431
00:18:39,039 --> 00:18:45,760
это просто формат для чтения этого текстового файла

433
00:18:43,520 --> 00:18:53,520
и после этого мы снова создадим целое число "col".

436
00:18:49,600 --> 00:18:57,440
начинающийся с 0 и целочисленный ряд, начинающийся с 0

438
00:18:54,960 --> 00:18:59,760
и снова цикл while

441
00:19:03,840 --> 00:19:08,559
так что меньше, чем maxScreenColl 

442
00:19:07,360 --> 00:19:19,280
а также row меньше, чем gp.maxScreenRow

447
00:19:17,039 --> 00:19:22,840
внутри этого цикла while мы будем читать этот текстовый файл

449
00:19:21,919 --> 00:19:30,080
и maxScreenCol или maxScreenRow является пределом этого цикла

451
00:19:26,720 --> 00:19:35,360
потому что у него нет данных за этой границей

459
00:19:46,160 --> 00:19:51,600
Так что этот BufferedReader может читать текстовые файлы

460
00:19:48,400 --> 00:20:02,000
и это readLine означает, что он будет читать одну строку

463
00:19:57,440 --> 00:20:05,679
и поместит ее в эту строку String "line"

464
00:20:02,000 --> 00:20:14,559
и как только мы прочитали строку, мы вводим еще один цикл while

477
00:20:31,600 --> 00:20:40,000
и двойные кавычки и пробел

479
00:20:36,799 --> 00:20:43,600
так что мы делаем вот что,

480
00:20:40,000 --> 00:20:49,840
из строки, которую мы только что прочитали, мы будем получать эти числа одно за другим

483
00:20:49,840 --> 00:20:56,320
и поместим их в этот переулок

485
00:20:55,200 --> 00:21:03,480
и затем мы создадим эту целочисленную переменную и назовем ее "num"

493
00:21:13,840 --> 00:21:20,159
и индекс "col"

494
00:21:17,840 --> 00:21:27,760
так что, по сути, мы меняем строку на целое число.

496
00:21:23,600 --> 00:21:31,679
этот readLine получает данные только как String

497
00:21:27,760 --> 00:21:37,919
и мы разделяем эту строку и это тоже String 

499
00:21:35,039 --> 00:21:41,120
поэтому нам нужно изменить это со String на Integer

500
00:21:37,919 --> 00:21:43,360
чтобы мы могли использовать их как число

502
00:21:42,320 --> 00:21:49,120
тогда мы будем использовать это целое число mapTileNum

508
00:21:54,080 --> 00:21:57,679
индекс col и row

511
00:21:59,280 --> 00:22:04,960
после этого мы увеличим col на 1

513
00:22:03,760 --> 00:22:13,720
и затем, если это значение достигнет maxScreenCol

525
00:22:28,559 --> 00:22:37,679
наконец, мы собираемся закрыть этот BufferedReader, потому что мы не собираемся использовать его

528
00:22:34,559 --> 00:22:43,039
Итак, в основном мы собираемся сканировать этот текстовый файл строка за строкой

530
00:22:41,200 --> 00:22:48,799
Итак, сначала эта строка и разделим ее на каждое число

532
00:22:44,480 --> 00:22:54,880
и приводим их к mapTileNum

534
00:22:51,520 --> 00:22:57,200
и закончив эту строку, затем 

535
00:22:54,880 --> 00:23:00,080
переходим к следующей строке и следующей...

537
00:23:00,080 --> 00:23:04,000
пока этот цикл не закончится

538
00:23:04,480 --> 00:23:11,840
так что теперь мы должны быть в состоянии загрузить данные карты

540
00:23:10,320 --> 00:23:19,360
так что давайте нарисуем загруженные данные карты

542
00:23:15,760 --> 00:23:20,159
нам просто нужно немного упорядочить этот цикл while

543
00:23:19,360 --> 00:23:28,480
вместо этого фиксированного изображения, сначала мы удалим это 

545
00:23:24,000 --> 00:23:31,280
и также, я думаю, мы создадим целое число

553
00:23:41,360 --> 00:23:46,000
Итак, мы снова начинаем с 0

556
00:23:47,360 --> 00:23:57,360
мы извлечем число из mapTileNum и получим его как номер плитки

559
00:23:55,840 --> 00:24:00,720
затем мы нарисуем изображение

563
00:24:02,799 --> 00:24:12,720
так что это будет работать как индекс этого массива Tile

569
00:24:15,600 --> 00:24:23,360
Так что если мы получим число 0 из этого

572
00:24:20,799 --> 00:24:26,799
это нарисует плитку травы 

573
00:24:23,360 --> 00:24:28,960
и если мы получим 1 на этой аллее, то

574
00:24:26,799 --> 00:24:31,679
он нарисует настенную плитку

575
00:24:28,960 --> 00:24:33,440
если 2, то нарисуется плитка воды

576
00:24:31,679 --> 00:24:41,919
Так что все хранится внутри этого массива mapTileNum

580
00:24:39,600 --> 00:24:44,400
теперь все должно быть в порядке, так что давайте проверим это

582
00:24:45,360 --> 00:24:48,240
упс

583
00:24:46,400 --> 00:24:50,480
почему

584
00:24:48,240 --> 00:24:50,480
ах

585
00:24:50,559 --> 00:25:02,400
585 00:24:50,559 --> 00:25:02,400 Хорошо, мы не вызывали этот метод карты загрузки

589
00:25:02,799 --> 00:25:06,240
все должно быть в порядке

590
00:25:04,320 --> 00:25:07,279
давайте проверим

591
00:25:06,240 --> 00:25:09,120
хорошо

594
00:25:10,720 --> 00:25:18,080
Итак, нам удалось нарисовать файл карты

596
00:25:23,840 --> 00:25:26,880
выглядит неплохо, я думаю

597
00:25:27,360 --> 00:25:34,000
Также я только что вспомнил еще одну вещь

600
00:25:34,000 --> 00:25:41,279
да, это просто прекрасно, но...

602
00:25:37,760 --> 00:25:48,400
вероятно, было бы лучше, если бы мы просто передали строку здесь

606
00:25:46,559 --> 00:25:55,440
мы передадим информацию о пути отсюда и получим ее в виде строки

613
00:26:02,559 --> 00:26:05,440
и поместим ее сюда

614
00:26:04,240 --> 00:26:14,000
потому что, возможно, позже вы создадите другую карту

618
00:26:11,200 --> 00:26:16,480
так что map02, map03, map04...

619
00:26:14,000 --> 00:26:20,960
и всякий раз, когда вы хотите загрузить другую карту

621
00:26:18,480 --> 00:26:25,360
вам просто нужно вызвать эту loadMap и ввести путь к файлу здесь

623
00:26:23,520 --> 00:26:27,840
так что вам не придется создавать еще один метод loadMap

627
00:26:34,159 --> 00:26:42,159
в любом случае, у нас получилось загрузить наш файл карты и нарисовать тайлы на экране

630
00:26:43,039 --> 00:26:49,440
но все равно это маленькая карта

631
00:26:45,520 --> 00:26:54,159
она всего лишь размером с один экран

633
00:26:52,960 --> 00:27:05,360
так что в следующий раз мы создадим карту мира, которую мы действительно будем использовать в нашей игре

636
00:27:00,080 --> 00:27:14,880
и реализуем игровую камеру, чтобы фоновые плитки менялись в зависимости от движения персонажа игрока

640
00:27:12,480 --> 00:27:17,880
спасибо за просмотр и до следующего раза

642
00:27:21,090 --> 00:27:27,760
[Музыка]

